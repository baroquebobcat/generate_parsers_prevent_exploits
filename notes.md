
intro

what are exploits?
 eg YAML

stop exploits 
  -blocking communications 
  -Well, goal: to make sure that inputs are good _before_ acting on them.
    we want to recognize their goodness / badness before we do anything
  (-yaml example allowed access to logic before checking if input was okay
    so we need to check first )
  - validate/recognize _before_ processing (before access to logic)


which brings me to LangSec
  -define who they are
  last bit is core principle of langsec 
  - WIN: validate/recognize _before_ processing (before access to logic)
  -DUCK!
  -recognize good input first (remove undefined behavior)
  (we'll come back to langsec)

  Okay great, we need to check first, but how do we recognize what input is good or bad?

  "Recognize?" are we talking about decidability?

  Yep.
---------

Theory of Computation:
Hand Wave Edition

Chapter 0
Decidability

Decidability?
In a formal system do all statements in that system have a yes or no answer?

"This statement is false."

In english, clearly, there are statements that are neither.

can a machine always give us a yes no answer, or will it run forever and never give an answer?

Turing et al did a bunch of math and proved that formal systems with certain properties can have unprovable statements.

In programming terms, the question is given this input, will a turing machine halt or not.


"halting problem"
"run forever"

/Big hand wave


Okay, great, there are undecidable problems that exist, but we need to secure our app. Can we decide whether a given input is good or bad?

:(

Unfortunately, for some types of inputs, this is impossible.
For certain categories of formal languages, this is a provably unsolvable problem.
If you can't recognized whether an input is good or bad, it is impossible to secure.

Oh shit.

GOOSE
go-forever-goose

"This system is very extendable/updatable because it embeds macros/scripting/programming language in data" --run like hell

http://langsec.org/insecurity-theory-28c3.pdf


Okay, fine. If you can't recognized whether an input is good or bad, it is impossible to secure. 

But remember, I said "certain types" of languages or inputs.

So what types are decidable and what types aren't? How do we tell the difference?

Well...This brings us back to our favorite book.


---------------
Theory of Computation:
Hand Wave Edition

Chapter 1
Formal Languages

Chapter 1a 
Formal Language Recognition

  Chomsky Hierarchy
  4 kinds & decidability for recognition
  (grab me and let's talk about automata later)
  TC is awesome for a programmer == awesome for a attacker Fucking scary, right? (GOOOSE)

Chapter 1b 
Comparing Formal Language Parsers

  pointing out context free is broken into two pieces:
  deterministic/non-deterministic
  deterministic context-free is the most powerful grammer you can use and still be able to compare the equvalence of different parser implementations

Woah.
Picture. (graph)

Ruby is here. YAML that allows Ruby, also here. HTML with script tags allowed, here.
Over here? JSON. 
also **some** kinds of XML.
standards compliant XML has stuff in it that would put it over here. HERE THERE BE DRAGONS.


Happy duck. Breathe.


--------------------
LANGSEC stuffs

WIN: (from before) validate/recognize _before_ processing (before access to logic)
WIN: use deterministic context-free languages (or less) as inputs
    -least powerful thing you can get away with
    - prefer JSON over XML (because JSON is deterministic context-free)

FAIL 1: using languages that are Turing complete as inputs

FAIL 2: parsing & validation in an ad hoc way

FAIL 3 : using parsers with wrong amount of computational power for the language
  -this is why, if you're trying to parse XML with regex, you're gonna have a bad time
  -because regex are designed to parse regular languages, so they don't work on context-free or higher

FAIL 4: using languages whose parsers cannot be compared
  - here you can compare, here you can't
  - ask me about it later

TL;DR use JSON if you're going to use an input language other than form data


---------------

Okay. Cool. I use Rails. Am I safe? How do I even???

Rails already deals with this in a lot of different ways. (list a couple quickly)

the reason the xml yaml thing happened is that rails has this big parsing infratracture that sits way in front of your application. it's a big black box.

it parses waaaay before your validation code runs.
it also parses even if you're not using the thing it's parsing.

"i see input, let's parse it!" That may or may not be a good idea

it's smart, and it mostly does the right things, but...
wouldn't it be better to parse things in a way that specifically tailored to your application?

--------

MuskOx

the specific input language of the endpoint of your application

you can say "for this one url, I only accept JSON data and it has to look like this." if it doesn't look like that, the code NEVER gets run and the user gets an error. 

the goal of muskox is to delay parsing until we know what the input language looks like.

when you do that, you're reducing the amount of undirected computation that the framework does for you

undirected =/= unexpected. you don't tell rails to parse things for you directly. but you expect it to be parsed at some point.

the problem is that it isn't under your control.


if you're using strong params, you're doing this kind of validation anyway. Why not constrain the operations performed on input even further?













------------------------------------


    What is langsec?
    langsec is using Theory of Computation and an understanding of formal language to reason about the security of applications and protocols
    part of infosec

    things that are bad according to lang sec
    1. using parsers with the wrong amount of computational power for the language
    2. parsing & validating input in an ad hoc way
    3. using languages that are turing complete as inputs
    4. using languages whose parsers cannot be compared (context sensitive)

    1. what does that even mean?
    here there be dragons
    well remember how you're not supposed to use Regex to parse XML, (unless you're using perl in which case, go ahead, but here there be dragons)
    there's a ToC reason for that.

    * treat computational power as a priviledged resource and that includes parsing
    * %section
    (screenshot)
    http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454


