---
title: Slides
layout: presentation
---
%section
  %h1 Generate Parsers! Prevent Exploits!
%section
  %h1 Or
%section
  %h1 LangSec for Ruby Devs
%section
  %h1 Or
%section
  %h1 Hey!
  %h1 Theory of Computation
  %h1 is relevant to Web Development
  %h2.fragment (maybe)
%section
  %h1 What?
  %h2.fragment exploits!
  %h2.fragment formal languages!
  %h2.fragment generating parsers!
  %h2.fragment ducks!
  %h2.fragment geese!
  %aside.notes
    Today I'm going to talk about exploits. How they relate to formal languages. How generating parsers for said formal languages can help to reduce your apps vulnerability to exploits.
    Also ducks and geese.
%section
  %h1 Exploits! They Suck!
%section
  %h2 Having an app exploited sucks
%section
  %h2 Attackers find
  %p.fragment Chink in armor
  %p.fragment hole in the wall
  %p.fragment crack in the dam
  %p.fragment analogy in analogy
  %p.fragment Achilles Heel
%section
  %h1 Attackers get
  %p.fragment crown jewels
  %p.fragment DB, eval
  %p.fragment shell
  %p.fragment ROOT!!
  %p.fragment the whole kit n' caboodle
%section
  %h1 PSA:
  %h1.fragment Your passwords are hashed and salted, Right?
%section
  %h1 Exploits ~~ Tricks
  %aside.notes
    Exploits feel like tricks.
%section
  %h1 Hard to predict
  %aside.notes
    They're hard to anticipate, and when you look at the different kinds of them, they feel
%section
  %h1 Unrelated
  %p.fragment Buffer Overflow
  %p.fragment SQL Injection
  %p.fragment XSS
  %p.fragment …
  %p.fragment ∞
  %aside.notes
    unrelated to each other.
    What do buffer overlows, SQL injections XSS have in common?
    Feels overwhelming
%section
  %h1 all different?
  %aside.notes
    They seem so different
%section
  %h1
    No
    %span.fragment !
    %span.fragment !
    %span.fragment !
  %aside.notes
    But they're not! not !
%section
  %h1 Exploits are all the same!
  %aside.notes
    Exploits are all the same kind of thing!
%section
  %h1 Unexpected Computation!
  %aside.notes
    Exploits are just unexpected computation that exist within your application.
%section
  %h1 Computation!
  %aside.notes
    And if they're computation, we can use tools for analyzing computation to better understand them and prevent them from showing up in our applications.
%section
  %h1 Theory of Computation: Hand Wave Edition
  %aside.notes
    :plain
      Yes, I'm talking about theory of computation.
      See! Relevant!
      Break out your text books and think back to those senior / grad level classes.
%section
  %h1 *NOT YET*
  %aside.notes
    :plain
      ha ha, not yet. we'll get to that I promise, in a bit.
%section
  %h1 Exploit != Trick
  %aside.notes
    Exploits aren't tricks. They're just means of computing things.
%section
  %h1 Exploit == Machine
  %aside.notes
    they're computing machines. And we can think about them as computing machines
    Since they're machines, let's talk about how they work.
%section
  %h1 
    Exploit === Weird Machine
    *
  %h2.fragment * technical term
  %aside.notes
    But they're weird machines.
%section
  %h1 How does an exploit work?
  %aside.notes
    So, what do exploits do?
%section
  %h2
    %ol
      %li.fragment Takes Input
      %li.fragment ??? (Does Stuff)
      %li.fragment
        %span Output
        %span.fragment /
        %span.fragment profit
    %h2.fragment (profit is important w/ exploits)
  %aside.notes
    slide contents
    so basically that's the same as any kind of computing machine really.
    program
%section
  %h1 Same as regular program
%section
  %h1 What's different?
  %aside.notes
    But there's a couple things that are different. Let's talk about exploit anatomy
%section
  %h1 Exploit anatomy
  %h2.fragment undefined behavior in your app
  %h2.fragment communication channels
  %aside.notes
    exploits are made up of two things.
    1. areas of undefined behavior in your applications
    2. communication channels to those areas of undefined behavior
    ideally you don't have 1., but as we usually write programs in Turing complete environments, that's hard to prove
    Easier is to attack number 2.
%section
  %h1 Exploits live
  %h1 inside
  %h1 your app / framework
  %aside.notes
    Where they live is inside your application. And because they live there, the way they get input is through your applications inputs.
%section
  %h1
    Input Via 
    Host Application's
    Inputs
  %aside.notes
    They have to get their input indirectly. Through your applications inputs.
    And that's because the inputs they receive come through the inputs to the host application
%section
  :graphviz
    digraph G {
      size = "7.5,10";

      compound=true;
      rankdir="LR";
      node [shape=box fontsize=10 fontname="Verdana" style="filled"];

      subgraph cluster0 {
       // height = 100;
        //scale = 2;
        label = "Your App";
        style="filled";
        //padding [style="invis"];
        "Exploit";
      }
      { node [shape=circle]; IN OUT  };
      "Exploit" -> IN [dir=back];
      "Exploit" -> OUT;
    }
  %aside.notes
    When an attacker wants to talk to an exploit, or see if one's there, they need to route input to that exploit through your application. So how does that work? Well,
%section
  %pre{style: "font-size:200%; width: 50%"}
    :plain
      App |
        | <- IN
        |

  %aside.notes
    (zoomin'in)
    When input for an exploit comes to your application
    Your application is sent some bad input
%section
  %h2 (past app code)
  %pre{style: "font-size:200%; width: 50%"}
    :plain
      App Code |
         /---| <- IN
         |   |
         v   |
  %aside.notes
    As it's processed, it somehow skips past your applications code. past the path you intended it to take, and instead goes somewhere else.

%section
  %h2 (to exploit)
  %pre{style: "font-size:200%; width: 50%"}
    :plain
           |     |
         v     |
      Exploit  |
  %aside.notes
    And ends up providing input to the exploit instead.
    You can see this in any exploit. SQL injection etc.
    And the exploit will send output back to the attacker, and they'll be able to play with the input to see what kind of response they get and what kinds of operations the exploit supports.
%section
  :graphviz
    digraph G {
      size = "7.5,10";

      compound=true;
      rankdir="LR";
      node [shape=box fontsize=10 fontname="Verdana" style="filled"];

      subgraph cluster0 {
       // height = 100;
        //scale = 2;
        label = "Your App";
        style="filled";
        //padding [style="invis"];
        "Exploit";
      }
      { node [shape=circle]; IN OUT  };
      "Exploit" -> IN [dir=back];
      "Exploit" -> OUT;
    }
%section
  %h1 stopping exploits
  %aside.notes
    So how do you stop exploits? Easiest way is to control their inputs
%section
  %h1 jam their comms!
%section
  %h1 validate inputs before use
  %aside.notes
    If you check inputs before using them, you cut down on the undefined inputs that enable attackers to find undefined behavior in your app
%section
  %h1 IN - what is it?
  %aside.notes
    but what are these inputs?
%section
  %h1 IN:
  %h2 instructions to the exploit
  %aside.notes
    Weird language
    crafted input
%section
  %h1 Exploit == Weird Machine
  %aside.notes
    Remember exploits are a weird machine, so these crafted inputs are the weird instructions for that weird machine
%section
  %h1 IN == program in exploit-ese
  %aside.notes
    ie a program for that weird machine
%section
  %h1 asm_sql_injection anyone?
  %aside.notes
    The input is like an assembly language, but for the specific weird machine.
%section
  %h1 
    Example:
    %br
    Rails XML(type=yaml)
  %h3 CVE-2013-0156
  %aside.notes
    Let's look at an example, the remote code exe bug from last year in rail's XML parser
%section
  :graphviz
    digraph G {
      size = "7.5,10";

      compound=true;
      rankdir="LR";
      node [shape=box fontsize=10 fontname="Verdana" style="filled"];

      subgraph cluster0 {
       // height = 100;
        //scale = 2;
        label = "Rails";
        style="filled";
        //padding [style="invis"];

        subgraph cluster1 {
         // height = 100;
          //scale = 2;
          label = "XML Parser";
          style="filled";
          //padding [style="invis"];
          "Exploit via YAML";
        }
      }
      { node [shape=circle]; IN OUT  };
      "Exploit via YAML" -> IN [dir=back];
      "Exploit via YAML" -> OUT;
    }
  %aside.notes
    Within the XML parser was some ill defined behavior that allowed yaml as an XML content type.
    yaml isn't safe--you can create Ruby objects of arbitrary classes--which allowed access to eval
%section
  %h2 (not actual program)
  - code "xml" do
    :plain
      <yaml type="yaml">
      ---- !ruby/object:Evil
        hi: eval_me
      </yaml>
%section
  %h1 ...
%section
  %h1 Running Ruby!
%section
  %h1 :-(
%section
  %h1 PSA:
  %h1.fragment Everybody's patched, right?
%section
  %h1 What's the real problem here?
%section
  %h1 Bad Input validation!
  %aside.notes
    these problems are caused by accepting inputs that your application handles incorrectly.
    and by doing interesting things with those inputs before you know what they are
%section
  %h1 What's the fix
  %h2.fragment Good Input Validation!
%section
  %h1 No Bad input allowed!
%section
  %h1 But How?
%section
  %h1 recognize inputs completely before processing them
%section
  %h1 LangSec
  %aside.notes
    this brings me to langsec or more fully
%section
  %h1 Language Theoretic Security
  %aside.notes
    lang sec started by a small group of security researchers relatively recently
    idea is to apply theory of computation principles regarding formal languages to describe the problem of securing protocols and network activities
    I think this is applicable not only to low level network protocol design but also application inputs.
    I got interested in lang sec in 2012 when I saw a talk at an infosec conference called Shmoocon by Meredith L Patterson. It was awesome.
%section
  %h1 recognize inputs completely before processing them
  %aside.notes
    that last just before introducing langsec is one of the important things langsec emphasizes.
    recognizing good input before acting on it reduces your apps undefined behaviors
%section
  %h1 [duck]
%section
  %h1 recognize inputs completely before processing them
  %aside.notes
    ok great, we need to check first, but how do we recognize what input is good or bad?
%section
  %h1 Recognize?
%section
  %h1 Are you talking about decidability?
%section
  %h1 yep
%section
  %h1 Theory of Computation: Hand Wave Edition
%section
  %h1 Chapter 0: Decidability
%section
  %h1 In a formal system, do all statements in that system have a yes or no answer?
  %aside.notes
    decidability is all about answer this 
%section
  %h1 This statement is false.
  %aside.notes
    In english, clearly, there are statements that are neither yes or no-able.
%section
  %h1 halting problem
  %h1.fragment undecidable
  %aside.notes
    Turing et al did a bunch of math and proved that formal systems with certain properties can have unprovable statements.
    he used something call the halting problem to describe it.
%section
  %h1 /handwave
%section
  %h1 Undecidable
  %h1.fragment what about input validation?
  %aside.notes
    Okay, great, there are undecidable problems that exist, but we need to secure our app. Can we decide whether a given input is good or bad?
%section
  %h1 :(
%section
  %h1 for certain types of input, recognizing is undecidable
%section
  %h1 [goose]
%section
  %h1 being sure an input won't trigger exploit:
  %h1.fragment impossible
%section
  %h1 [go-forever-goose]
%section
  %h1 "certain types"
  %aside.notes
    So what types are decidable and what types aren't? How do we tell the difference?
%section
  %h1 Theory of Computation: Hand Wave Edition
%section
  %h1 Chapter 1: Formal Languages
%section
  %h1 Chomsky Hierarchy
  %img{src: '/images/c_hierarchy.png'}
  %aside.notes
    This is the chomsky hierarchy
    If you've ever taken a compilers course you probably covered it in depth. I'm not doing that. I'm just going to talk about each real quick
%section
  %h1 Regular
  %h2 Boring and Safe
  %h2 No matching parens
  %h2 features: delimiters
%section
  %h1 Context Free
  %h2 less boring, mostly safe
  %h2 features: {(nesting)}
%section
  %h1 Context Sensitive
  %h2 less boring, mostly safe
  %h2 features: field length prefixes allowed
%section
  %h1 Recursively Enumerable
  %h2 can describe turing machine
  %h2 most powerful
%section
  %h1 Chapter 1.a: Formal Language Recognition
  %aside.notes
    what do these have to do w/ security?
    what we're really interested in from a sec stand pt is recognition
%section
  %h1 Decidability of formal language recognition
  %img{src: '/images/c_hierarchy_decide_recognition.png'}
  %aside.notes 
    here's what the hierarchy looks like w/ the languages that you can recognize decidably.
    It's most of them.
%section
  %h1 Recursively Enumerable
  %h2 can describe turing machine
  %h2 most powerful
  %aside.notes
    RE is also known as the unrestricted grammar. It has all the things. As it has all the things, parsing it is equivalent to simulating a turing machine.
    eg if you take a programming language as input and then execute it!
%section
  %h1 [angry goose]
%section
  %h1 Context Sensitive 
  %h1 and below
  %h1.fragment Decidable
  %aside.notes
    all the others are decidable, so that's cool.
    decidable languages include most things you would reasonably use like JSON, that said particular instances of JSON / XML are not necessarily decidable
%section
  %h1 [happy duck]
%section
  %h1 Chapter 1.b: Comparing Formal Language Parsers
%section
  %h1 Context Free has two parts
  %h2.fragment Deterministic
  %h2.fragment Non-Deterministic
%section
  %h2 deterministic context-free
  %h2 and regular
  %h2 comparing parser equivalency:
  %h2.fragment decidable
%section
  %h1 Woah
  %img{src: '/images/c_hierarchy_D_ND_CF.png'}
  %aside.notes
    RE is ruby
    yaml also there
    html w/ script RE ish
    D-CF JSON!!
    XML?? context sensitive I think, depending on the schema
%section
  %h1 [happy duck]
%section
  %h1 recognize inputs completely before processing them
  %aside.notes
    so where were we, oh yeah. lang sec sez qt slide
%section
  %h1 use deterministic context-free languages (or less) as inputs
  %aside.notes
    WIN: use deterministic context-free languages (or less) as inputs
    *least powerful thing you can get away with
    * prefer JSON over XML (because JSON is deterministic context-free)
%section
  %h1 LangSec no noes
  %h2
    %ul
      %li.fragment Turing Complete Inputs
      %li.fragment ad hoc input validation
      %li.fragment weak parsers checking strong languages
%section
  %h1 Turing Complete Inputs
%section.biggest
  %blockquote
    "This system is very extendable/updatable
    because it embeds macros/scripting/programming language in data" --run like hell
  %p -- Science of Insecurity
  %aside.notes
    to quote Meredith's Science of Insecurity
    maybe that'll give you a clue
    eg XML(YAML)
%section
  %h1 ad hoc input validation
  %aside.notes
    when validation & parsing scattered, the machine that does parsing has many more states and potential undefined behaviors
%section
  %h1 weak parsers checking strong languages
%section
  :rubycode
      if in_xml =~ /valid-codes/
        fire_z_missiles(in_xml)
      end
%section
  %h1 TL;DR Use JSON
%section
  %h1 WRT Rails
  %aside.notes
    Okay. Cool. I use Rails. Am I safe? How do I even???
    Rails already deals with this in a lot of different ways. (list a couple quickly)
    eg HTML sanitization
    the reason the xml yaml thing happened is that rails has this big parsing infratracture that sits way in front of your application. it's a big black box.
%section
  %h1 80% cool
  









%section
  %h1 Theory of Computation: cliff notes
%section
  %h1 Theory of Computation: hand wave section
%section
  %h1 decidability
%section
  %h1 But, input validation
%section
  %h1 your app's input ~= formal language
%section
  %h1 merely recognizing formal languages can sometimes be undecidable
%section
  %h1 ???
%section
  %h1 decidability chat
  %h2.fragment App: Can I parse this?
  %h2.fragment Parser: *Runs forever*
  %aside.notes
    actually, a lot of exploits work this way. the goal is to ddos
%section
  %h1 What's an undecidable language?
  %aside.notes
    this begs the question, how do I decide (*snork) if my input is decidable?
%section
  %h1 look back at XML(type=yaml)
%section
  %h1 YAML mixes parsing / processing
%section
  %h1 mixes parsing / processing -> undefined behavior
%section
  %h1 bad!
%section
  %h1 Goal:
  %h2.fragment rm -rf undefined_behavior
%section
  %h1 don't allow undefined inputs!
%section
  %h1 ↶
%section
  %h1 Only allow defined inputs!
%section
  %h1 Patched Postel Principle
  - code "diff" do
    :plain
      The Postel Principle Patch:

      --- ietf/postels-principle
      +++ ietf/postels-principle
        
      - Be liberal about what you accept.

      + Be definite about what you accept.(*) 
      +
      + Treat inputs as a language, accept it with a matching computational
      + power, generate its recognizer from its grammar.
      +
      + Treat input-handling computational power as privilege, and reduce it
      + whenever possible.
      +
      +
      + (*) For the sake of your users, be definite about what you accept.
      + Being liberal worked best for simpler protocols and languages,
      + and is in fact limited to such languages; be sure to keep your
      + language regular or at most context free (no length fields).    
      + Being more liberal did not work so well for early IPv4 stacks: 
      + they were initially vulnerable to weak packet parser attacks, and 
      + ended up eliminating many options and features from normal use. 
      + Furthermore, presence of these options in traffic came to be regarded 
      + as a sign of suspicious or malicious activities, to be mitigated by 
      + traffic normalization or outright rejection. At current protocol 
      + complexities, being liberal actually means exposing the users of your 
      + software to intractable or malicious computations. 
  :markdown
    [cite](http://langsec.org/postel-principle-patch.txt)
%section
  %blockquote.bigger Be definite about what you accept.(*)
%section
  %blockquote.bigger 
    Treat inputs as a language, accept it with a matching computational power, generate its recognizer from its grammar.
%section
  %blockquote.bigger
    Treat input-handling computational power as privilege, and reduce it whenever possible.
%section
  %h1 Defining inputs...
  %h2.fragment Isn't that a pain?
%section
  %h1 
    %span Yes!
    %span.fragment yes it is!
%section
  %h1 But, we already do!
%section
  %h1 Rails input validation
  %h2.fragment Rails 3 attr_accessible
%%section
  %h1  Rails 3 attr_accessible
  :rubycode
    attr_accessible :name
    attr_accessible :name, :credit_rating,
                    :as => :admin
  :markdown
    [api docs](http://apidock.com/rails/ActiveModel/MassAssignmentSecurity/ClassMethods/attr_accessible)
%section
  :graphviz
    digraph {
      rankdir="LR";
      bytes -> "hashes n arrays";
      "hashes n arrays" -> controller;
      controller -> model [label="Input Checked Here", labelloc=b];
    }
%section
  %h1 pluses
  %h2.fragment all access controlled
  %h2.fragment blows up on bad keys
%section
  %h1 minuses
  %h2.fragment definition / usage in different locations
  %h2.fragment different use case handling

%section
  %h1 Rails input validation
  %h2 Rails 3 attr_accessible
  %h2.fragment Rails 4 Strong Parameters
%%section
  %h1 Rails 4 Strong Parameters
  :rubycode
    params.require(:person).
        permit(:name, :age,
               pets_attributes: 
                 [ :name, :category ])
  :markdown
    [api docs](http://edgeapi.rubyonrails.org/classes/ActionController/StrongParameters.html)

%section
  %h1 Pluses
  %h2.fragment access / usage in same location
  %h2.fragment schema allows for nesting
%section
  %h1 minuses
  %h2.fragment silently strips unpermitted keys
  %h2.fragment Schema is ambiguous
%section
  %h1 Why not earlier?
%section
  :graphviz
    digraph {
      rankdir="LR";
      bytes -> "hashes n arrays" [label="Input Checked Here", labelloc=b];
      "hashes n arrays" -> controller ;
      controller -> model;
    }
%section
  :markdown
    ![muskox](/images/muskox_logo.png)
%section
  %h2 Muskox is a schema based Parser Generator
%section
  %h2 Give it a JSON Schema definition
  - code "ruby" do
    :plain
      extend Muskox::Extensions
          add_parser    :user,
            type:       :object,
            properties: {
              name:  { type: :string },
              email: { type: :string }
            }
%section
  %h1 And it will only allow valid strings to be parsed
%section
  .bigger
    - code "ruby" do
      :plain
        MyParsers.parsers[:user].parse(
          %!{"name":"me", "email":"x@y.com"}!)
        # => {"name"=>"me", "email"=>"x@y.com"} 
%section
  .bigger
    - code "ruby" do
      :plain
        MyParsers.parsers[:user].parse(
          %!{"hash_dos1":1, "hash_dos2":1, "hash_dos3":1}!)
        # Muskox::ParserError: 
        #   Unexpected property: [hash_dos1] at root.
        #   Allowed properties: [name, email]
%section
  %h1 Structure
%section
  %h1 Break Parser in Two
  .graph.fragment
    :graphviz
      digraph {
        rankdir="LR";
        tokenizer -> validator;
      }
%section
  %h1 tokenizer
  %h2.fragment recognizes language (JSON)
  %h2.fragment passes tokens to validator
%section
  %h1 validator
  %h2.fragment validates against provided schema
  %h2.fragment uses tokens to create Ruby objects
%section
  %h1 MuskOx w/ Rails
%section
  %h1 Replace Strong Params
  - code "ruby" do
    :plain
      def login_params
        params.require(:user).permit(:login, :password)
      end
%section
  %h1 Replace Strong Params
  - code "ruby" do
    :plain
      muskox_params :user_params do |m|
        m.require(:user).permit(:login, :password)
      end
%section
  %h1 Muskox Future
  %h2 new tokenizer formats: XML, Form encoded data, ...
%section
  %h1 References
  %h2 langsec.org
  %h2 github.com/baroquebobcat/muskox
  %aside.notes
    langsec.org has a lot of links to presentations that go through the langsec stuff with more rigor than I did, so if you want to learn more about that, it's a great place to get started.
    Meredith L. Patterson
%section
  %h1 Qs / Interesting Automata?
%section
  :markdown
    ![gnip](/images/GnipLogo.png)