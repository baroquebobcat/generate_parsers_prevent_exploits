---
title: Slides
layout: presentation
---
%section
  %h1 Generate Parsers! Prevent Exploits!
%section
  %h1 Or
%section
  %h1 LangSec for Ruby Devs
%section
  %h1 Or
%section
  %h1 Hey!
  %h1 Theory of Computation
  %h1 is relevant to Web Development
%section
  %h1 (maybe)

%section
  %h2 Having an app exploited sucks
%section
  %h2 Attackers find
  %p.fragment Chink in armor
  %p.fragment hole in the wall
  %p.fragment crack in the dam
  %p.fragment analogy in analogy
  %p.fragment Achilles Heel
%section
  %h1 Attackers get
  %p.fragment crown jewels
  %p.fragment DB, eval
  %p.fragment shell
  %p.fragment ROOT!!
  %p.fragment the whole kit n' caboodle
%section
  %h1 Your passwords are hashed and salted. Right?
%section
  %h1 Exploits ~~ Tricks
%section
  %h1 Hard to predict
%section
  %h1 Unrelated
  %p.fragment Buffer Overflow
  %p.fragment SQL Injection
  %p.fragment XSS
  %p.fragment …
  %p.fragment ∞
%section
  %h1 all different
%section
  %h1
    No
    %span.fragment !
    %span.fragment !
    %span.fragment !
%section
  %h1 Exploits are all the same!
%section
  %h1 Unexpected Computation!
%section
  %h1 Computation!
%section
  %h1 Theory of Computation: cliff notes
%section
  %h1 *NOT YET*
%section
  %h1 Exploit == Machine
%section
  %h1 How does an exploit work?
%section
  %h2.fragment Takes Input
  %h2.fragment Does Stuff
  %h2.fragment ...
  %h2
    %span.fragment Output
    %span.fragment / profit
%section
  %h2 (profit is important w/ exploits)
%section
  %h2 What's different?
%section
  %h1 Input Via Host Application's Inputs.
%section
  %h1 Exploits live in your app, framework ...
  %h2.fragment In Undefined behavior
%section
  %h1 Exploit Communication
%section
  :graphviz
    digraph G {
      size = "7.5,10";

      compound=true;
      rankdir="LR";
      node [shape=box fontsize=10 fontname="Verdana" style="filled"];

      subgraph cluster0 {
       // height = 100;
        //scale = 2;
        label = "Your App";
        style="filled";
        //padding [style="invis"];
        "Exploit";
      }
      { node [shape=circle]; IN OUT  };
      "Exploit" -> IN [dir=back];
      "Exploit" -> OUT;
    }
%section
  %h2 (zoom in on app barrier)
  %pre{style: "font-size:200%; width: 50%"}
    :plain
      App |
        | <- IN
        |


%section
  %h2 (past app code)
  %pre{style: "font-size:200%; width: 50%"}
    :plain
      App Code |
         /---| <- IN
         |   |
         v   |
%section
  %h2 (to exploit)
  %pre{style: "font-size:200%; width: 50%"}
    :plain
           |     |
         v     |
      Exploit  |
%section
  %h1 IN:
  %h2 instructions to exploit
%section
  %h1 IN == program in exploit-ese
%section
  %h1 weird instructions
%section
  %h1 Example: XML(type=yaml)
%section
  :graphviz
    digraph G {
      size = "7.5,10";

      compound=true;
      rankdir="LR";
      node [shape=box fontsize=10 fontname="Verdana" style="filled"];

      subgraph cluster0 {
       // height = 100;
        //scale = 2;
        label = "Rails";
        style="filled";
        //padding [style="invis"];

        subgraph cluster1 {
         // height = 100;
          //scale = 2;
          label = "XML Parser";
          style="filled";
          //padding [style="invis"];
          "Exploit via YAML";
        }
      }
      { node [shape=circle]; IN OUT  };
      "Exploit via YAML" -> IN [dir=back];
      "Exploit via YAML" -> OUT;
    }
%section
  %h2 (not actual program)
  - code "xml" do
    :plain
      <yaml type="yaml">
      ---- !ruby/object:Evil
        hi: eval_me
      </yaml>
%section
  %h1 ...
%section
  %h1 Running Ruby!
%section
  %h1 :-(
%section
  %h1 Everybody's patched, right?
%section
  %h1 What's the real problem here?
%section
  %h1 Bad Input validation!
%section
  %h1 Language Theoretic Security
%section
  %h1 ad hoc
%section
  %h1 parser power problems
%section
  %h1 too low for language
%section
  %h2 (screenshot)
  %h2 http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
%section
  %h1 What's the fix
  %h2.fragment Input Validation!
%section
  %h1 No Bad input allowed!
%section
  %h1 But How?
  %h2.fragment treat input as formal language
%section
  %h1
    :markdown
      _decide_ whether input is good/bad.
%section
  %h1 Decide!
%section
  %h1 Theory of Computation: cliff notes
%section
  %h1 *Not Yet*
%section
  %h1
    :markdown
      _recognize_ good input before processing
%section
  %h1 look back at XML(type=yaml)
%section
  %h1 YAML mixes parsing / processing
%section
  %h1 mixes parsing / processing -> undefined behavior
%section
  %h1 bad!
%section
  %h1 Goal:
  %h2.fragment rm -rf undefined_behavior
%section
  %h1 don't allow undefined inputs!
%section
  %h1 ↶
%section
  %h1 Only allow defined inputs!
%section
  %h1 Patched Postel Principle
  - code "diff" do
    :plain
      The Postel Principle Patch:

      --- ietf/postels-principle
      +++ ietf/postels-principle
        
      - Be liberal about what you accept.

      + Be definite about what you accept.(*) 
      +
      + Treat inputs as a language, accept it with a matching computational
      + power, generate its recognizer from its grammar.
      +
      + Treat input-handling computational power as privilege, and reduce it
      + whenever possible.
      +
      +
      + (*) For the sake of your users, be definite about what you accept.
      + Being liberal worked best for simpler protocols and languages,
      + and is in fact limited to such languages; be sure to keep your
      + language regular or at most context free (no length fields).    
      + Being more liberal did not work so well for early IPv4 stacks: 
      + they were initially vulnerable to weak packet parser attacks, and 
      + ended up eliminating many options and features from normal use. 
      + Furthermore, presence of these options in traffic came to be regarded 
      + as a sign of suspicious or malicious activities, to be mitigated by 
      + traffic normalization or outright rejection. At current protocol 
      + complexities, being liberal actually means exposing the users of your 
      + software to intractable or malicious computations. 
  :markdown
    [cite](http://langsec.org/postel-principle-patch.txt)
%section
  %blockquote Be definite about what you accept.(*)
%section
  %blockquote 
    Treat inputs as a language, accept it with a matching computational power, generate its recognizer from its grammar.
%section
  %blockquote
    Treat input-handling computational power as privilege, and reduce it whenever possible.
%section
  %h1 Defining inputs...
  %h2.fragment Isn't that a pain?
%section
  %h1 Yes! yes it is!
%section
  %h1 But, we already do!
%section
  %h1 Rails input validation
  %h2.fragment Rails 3 attr_accessible
%%section
  %h1  Rails 3 attr_accessible
  - code "ruby" do
    :plain
      attr_accessible :name
      attr_accessible :name, :credit_rating, :as => :admin
  :markdown
    [api docs](http://apidock.com/rails/ActiveModel/MassAssignmentSecurity/ClassMethods/attr_accessible)
%section
  :graphviz
    digraph {
      rankdir="LR";
      bytes -> "hashes n arrays";
      "hashes n arrays" -> controller;
      controller -> model [label="Input Checked Here", labelloc=b];
    }
%section
  %h1 pluses
  %h2.fragment all access controlled
  %h2.fragment blows up on bad keys
%section
  %h1 minuses
  %h2.fragment access / usage in different locations
  %h2.fragment different use case handling

%section
  %h1 Rails input validation
  %h2 Rails 3 attr_accessible
  %h2.fragment Rails 4 Strong Parameters
%%section
  %h1 Rails 4 Strong Parameters
  - code "ruby" do
    :plain
      params.require(:person).
          permit(:name, :age, pets_attributes: [ :name, :category ])
  :markdown
    [api docs](http://edgeapi.rubyonrails.org/classes/ActionController/StrongParameters.html)

%section
  %h1 Pluses
  %h2.fragment access / usage in same location
  %h2.fragment schema allows for nesting
%section
  %h1 minuses
  %h2.fragment silently strips unpermitted keys
  %h2.fragment Schema is ambiguous
%section
  %h1 Why not earlier?
%section
  :graphviz
    digraph {
      rankdir="LR";
      bytes -> "hashes n arrays" [label="Input Checked Here", labelloc=b];
      "hashes n arrays" -> controller ;
      controller -> model;
    }
%section
  :markdown
    ![muskox](/images/muskox_logo.png)
%section
  %h2 Muskox is a schema based Parser Generator
%section
  %h2 Give it a JSON Schema definition
  - code "ruby" do
    :plain
      extend Muskox::Extensions
          add_parser    :user,
            type:       :object,
            properties: {
              name:  { type: :string },
              email: { type: :string }
            }
%section
  %h1 And it will only allow valid strings to be parsed.
%section
  .bigger
    - code "ruby" do
      :plain
        MyParsers.parsers[:user].parse(
          %!{"name":"me", "email":"x@y.com"}!)
        # => {"name"=>"me", "email"=>"x@y.com"} 
%section
  .bigger
    - code "ruby" do
      :plain
        MyParsers.parsers[:user].parse(
          %!{"hash_dos1":1, "hash_dos2":1, "hash_dos3":1}!)
        # Muskox::ParserError: 
        #   Unexpected property: [hash_dos1] at root.
        #   Allowed properties: [name, email]
%section
  %h1 Structure
%section
  %h1 Break Parser in Two
  .graph.fragment
    :graphviz
      digraph {
        rankdir="LR";
        tokenizer -> validator;
      }
%section
  %h1 tokenizer
  %h2.fragment recognizes language (JSON)
  %h2.fragment passes tokens to validator
%section
  %h1 validator
  %h2.fragment validates against provided schema
  %h2.fragment uses tokens to create Ruby objects
%section
  %h1 MuskOx w/ Rails
%section
  %h1 Replace Strong Params
  - code "ruby" do
    :plain
      def login_params
        params.require(:user).permit(:login, :password)
      end
%section
  %h1 Replace Strong Params
  - code "ruby" do
    :plain
      muskox_params :user_params do |m|
        m.require(:user).permit(:login, :password)
      end
%section
  %h1 Muskox Future
  %h2 new tokenizer formats: XML, Form encoded data, ...
%section
  %h1 References
  %h2 langsec.org
  %h2 github.com/baroquebobcat/muskox
%section
  %h1 Qs / Complexity classes?
%section
  :markdown
    ![gnip](/images/GnipLogo.png)