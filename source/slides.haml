---
title: Slides
layout: presentation
---
%section
  %h1 Generate Parsers! Prevent Exploits!
%section
  %h1 Or
%section
  %h1 LangSec for Ruby Devs
%section
  %h1 Or
%section
  %h1 Hey!
  %h1 Theory of Computation
  %h1 is relevant to Web Development
  %h2.fragment (maybe)
%section
  %h1 What?
  %h2.fragment exploits!
  %h2.fragment formal languages!
  %h2.fragment generating parsers!
  %aside.notes
    Today I'm going to talk about exploits. How they relate to formal languages. How generating parsers for said formal languages can help to reduce your apps vulnerability to exploits.
    Also ducks and geese.
    get it? duck duck goose <pic?>
%section.fullscreen
  %img{src: '/images/ducks/5126832913_ducklings.jpg'}
%section.fullscreen
  %img{src: '/images/ducks/4655500165_smily_duck.jpg'}
%section.fullscreen
  %img{src: '/images/geese/10501479265_distainful_goose.jpg'}

%section
  %h1 Exploits! They Suck!
%section
  %h1 Having an app exploited sucks
%section
  %h1 Attackers find
  %h2.fragment Chink in armor
  %h2.fragment hole in the wall
  %h2.fragment crack in the dam
  %h2.fragment analogy in analogy
  %h2.fragment Achilles Heel
%section
  %h1 Attackers get
  %h2.fragment crown jewels
  %h2.fragment DB, eval
  %h2.fragment shell
  %h2.fragment ROOT!!
  %h2.fragment the whole kit n' caboodle
%section
  %h1 PSA:
  %h1.fragment Your passwords are hashed and salted, Right?
%section
  %h1 Exploits ~~ Tricks
  %aside.notes
    Exploits feel like tricks.
%section
  %h1 Hard to predict
  %aside.notes
    They're hard to anticipate, and when you look at the different kinds of them, they feel
%section
  %h1 Unrelated
  %h2.fragment Buffer Overflow
  %h2.fragment SQL Injection
  %h2.fragment XSS
  %h2.fragment …
  %h2.fragment ∞
  %aside.notes
    unrelated to each other.
    What do buffer overlows, SQL injections XSS have in common?
    Feels overwhelming all the different ways an app can be attacked
%section
  %h1 all different?
  %aside.notes
    They seem so different
%section
  %h1
    No
    %span.fragment !
    %span.fragment !
    %span.fragment !
  %aside.notes
    But they're not! not !
%section
  %h1 Exploits are all the same!
  %aside.notes
    Exploits are all the same kind of thing!
%section
  %h1 Unexpected Computation!
  %aside.notes
    Exploits are just unexpected computation that exist within your application.
%section
  %h1 Computation!
  %aside.notes
    And if they're computation, we can use tools for analyzing computation to better understand them and prevent them from showing up in our applications.
%section
  %h1 Theory of Computation: Hand Wave Edition
  %img{src:'/images/kermit.gif'}
  %aside.notes
    :plain
      Yes, I'm talking about theory of computation.
      See! Relevant!
      Break out your text books and think back to those senior / grad level classes.
%section
  %h1 *NOT YET*
  %aside.notes
    :plain
      ha ha, not yet. we'll get to that I promise, in a bit.
%section
  %h1 Exploit != Trick
  %aside.notes
    Exploits aren't tricks. They're just means of computing things.
%section
  %h1 Exploit == Machine
  %aside.notes
    they're computing machines. And we can think about them as computing machines
    Since they're machines, let's talk about how they work.
%section
  %h1 How does an exploit work?
  %aside.notes
    So, what do exploits do?
    At a really hi, almost useless level, how do exploits work?
%section
  %h1
    %ol
      %li.fragment Takes Input
      %li.fragment ??? (Does Stuff)
      %li.fragment
        %span Output
        %span.fragment /
        %span.fragment profit
    %h2.fragment (profit is important w/ exploits)
  %aside.notes
    slide contents
    so basically that's the same as any kind of computing machine really.
    program
%section
  %h1 Same as regular program
%section
  %h1 What's different?
  %aside.notes
    But there's a couple things that are different. Let's talk about exploit anatomy
%section
  %h1 Exploit anatomy
  %h2.fragment undefined behavior in your app
  %h2.fragment communication channels
  %aside.notes
    exploits are made up of two things.
    1. areas of undefined behavior in your applications
    2. communication channels to those areas of undefined behavior
    ideally you don't have 1., but as we usually write programs in Turing complete environments, that's hard to prove
    Easier is to attack number 2.
%section
  %h1 Exploits live
  %h1 inside
  %h1 your app / framework
  %aside.notes
    Where they live is inside your application. And because they live there, the way they get input is through your applications inputs.
%section
  %h1
    Input Via 
    Host Application's
    Inputs
  %aside.notes
    They have to get their input indirectly. Through your applications inputs.
    specially crafted.
    weirdly formatted.
    odd operations.
%section
  %h1 
    Exploit === Weird Machine
    *
  %h2.fragment * technical term
  %aside.notes
    They're weird machines.
    And yes that's _the_ technical term
%section
  :graphviz
    digraph G {
      size = "7.5,10";

      compound=true;
      rankdir="LR";
      node [shape=box fontsize=10 fontname="Verdana" style="filled"];

      subgraph cluster0 {
       // height = 100;
        //scale = 2;
        label = "Your App";
        style="filled";
        //padding [style="invis"];
        "Exploit";
      }
      { node [shape=circle]; IN OUT  };
      "Exploit" -> IN [dir=back];
      "Exploit" -> OUT;
    }
  %aside.notes
    When an attacker wants to talk to an exploit, or see if one's there, they need to route input to that exploit through your application. So how does that work? Well,
%section
  %pre.asciiart
    :plain
      App |
        | <- IN
        |

  %aside.notes
    (zoomin'in)
    When input for an exploit comes to your application
    Your application is sent some bad input
%section
  %h2 (past app code)
  %pre.asciiart
    :plain
      App Code |
         /---| <- IN
         |   |
         v   |
  %aside.notes
    As it's processed, it somehow skips past your applications code. past the path you intended it to take, and instead goes somewhere else.

%section
  %h2 (to exploit)
  %pre.asciiart
    :plain
           |     |
         v     |
      Exploit  |
  %aside.notes
    And ends up providing input to the exploit instead.
    You can see this in any exploit. SQL injection etc.
    And the exploit will send output back to the attacker, and they'll be able to play with the input to see what kind of response they get and what kinds of operations the exploit supports.
%section
  :graphviz
    digraph G {
      size = "7.5,10";

      compound=true;
      rankdir="LR";
      node [shape=box fontsize=10 fontname="Verdana" style="filled"];

      subgraph cluster0 {
       // height = 100;
        //scale = 2;
        label = "Your App";
        style="filled";
        //padding [style="invis"];
        "Exploit";
      }
      { node [shape=circle]; IN OUT  };
      "Exploit" -> IN [dir=back];
      "Exploit" -> OUT;
    }
  %aside.notes
    get out put out of it. tinker with it.
%section
  %h1 stopping exploits
  %aside.notes
    So how do you stop exploits? Easiest way is to control their inputs
%section
  %h1 jam their comms!
%section
  %h1 validate inputs before use
  %aside.notes
    If you check inputs before using them, you cut down on the undefined inputs that enable attackers to find undefined behavior in your app
%section
  %h1 IN - what is it?
  %pre.asciiart
    :plain
      App |
        | <- IN
        |
  %aside.notes
    but what are these inputs?
%section
  %h1 IN:
  %h2 instructions to the exploit
  %aside.notes
    Weird language
    crafted input
%section
  %h1 Exploit == Weird Machine
  %aside.notes
    Remember exploits are a weird machine, so these crafted inputs are the weird instructions for that weird machine
%section
  %h1 IN:
  %h2 program in exploit-ese
  %aside.notes
    ie a program for that weird machine
%section
  %h1 asm_sql_injection anyone?
  %aside.notes
    The input is like an assembly language, but for the specific weird machine.
%section
  %h1 
    Example:
    %br
    Rails XML(type=yaml)
  %h3 CVE-2013-0156
  %aside.notes
    Let's look at an example, the remote code exe bug from last year in rail's XML parser
%section
  :graphviz
    digraph G {
      size = "7.5,10";

      compound=true;
      rankdir="LR";
      node [shape=box fontsize=10 fontname="Verdana" style="filled"];

      subgraph cluster0 {
       // height = 100;
        //scale = 2;
        label = "Rails";
        style="filled";
        //padding [style="invis"];

        subgraph cluster1 {
         // height = 100;
          //scale = 2;
          label = "XML Parser";
          style="filled";
          //padding [style="invis"];
          "Exploit via YAML";
        }
      }
      { node [shape=circle]; IN OUT  };
      "Exploit via YAML" -> IN [dir=back];
      "Exploit via YAML" -> OUT;
    }
  %aside.notes
    Within the XML parser was some ill defined behavior that allowed yaml as an XML content type.
    yaml isn't safe--you can create Ruby objects of arbitrary classes--which allowed access to eval
%section
  %h2 (not actual program)
  :xmlcode
    <yaml type="yaml">
    ---- !ruby/object:Evil
      hi: eval_me
    </yaml>
%section
  %h1 ...
%section
  %h1 Running Ruby!
%section
  %h1 :-(
%section
  %img{src: '/images/geese/132425620_yelling_goose.jpg'}
%section
  %h1 PSA:
  %h1.fragment Everybody's patched, right?
%section
  %h1 What's the real problem here?
%section
  %h1 Bad Input validation!
  %aside.notes
    these problems are caused by accepting inputs that your application handles incorrectly.
    and by doing interesting things with those inputs before you know what they are
%section
  %h1 What's the fix
  %h2.fragment Good Input Validation!
%section
  %h1 No Bad input allowed!
%section
  %h1 But How?
%section
  %h1 recognize inputs completely before processing them
  %aside.notes
    then if theyr good, we know we can do the right thing and if theyr bad, we can succeed in rejecting them!
%section
  %h1 LangSec
  %aside.notes
    mentioned breifly in title, but other than that not yet
%section
  %h1 Language Theoretic Security
  %aside.notes
    lang sec started by a small group of security researchers relatively recently
    idea is to apply theory of computation principles regarding formal languages to describe the problem of securing protocols and network activities
    I think this is applicable not only to low level network protocol design but also application inputs.
    I got interested in lang sec in 2012 when I saw a talk at an infosec conference called Shmoocon by Meredith L Patterson. It was awesome.
%section
  %h1 recognize inputs completely before processing them
  %aside.notes
    that last just before introducing langsec is one of the important things langsec emphasizes.
    recognizing good input before acting on it reduces your apps undefined behaviors
%section.fullscreen
  %img{src: '/images/ducks/4655500165_smily_duck.jpg'}
  %aside.notes
    recognizing is just ducky for security
%section
  %h1 recognize inputs completely before processing them
  %aside.notes
    ok great, we need to check first, but how do we recognize what input is good or bad?
%section
  %h1 Recognize?
%section
  %h1 Are you talking about decidability?
%section
  %h1 yep
%section
  %h1 Theory of Computation: Hand Wave Edition
  %img{src:'/images/kermit.gif'}
%section
  %h1 Chapter 0: Decidability
%section
  %h1 In a formal system, do all statements in that system have a yes or no answer?
  %aside.notes
    decidability is all about answer this
    Let's see an example
%section
  %h1 an example
  %aside.notes
    in the natural language known as english
%section
  %h1 "This statement is false."
  %aside.notes
    In english, clearly, there are statements that are neither yes or no-able.
%section
  %h1 halting problem
  %h1.fragment undecidable
  %aside.notes
    Turing et al did a bunch of math and proved that formal systems with certain properties can have unprovable statements.
    he used something call the halting problem to describe it.
%section
  %h1 /handwave
%section
  %h1 Undecidable problems exist
  %h1.fragment what about input validation?
  %aside.notes
    Okay, great, there are undecidable problems that exist, but we need to secure our app. Can we decide whether a given input is good or bad?
%section
  %h1 :-(
%section
  %h1 for certain types of input, recognizing is undecidable
%section
  %img{src: '/images/geese/132425620_yelling_goose.jpg'}
%section
  %h1 being sure an input won't trigger exploit:
  %h1.fragment impossible
%section
  %img{src: '/images/geese/7306896928_goose_attack.jpg'}
%section
  %h1 "certain types"
  %aside.notes
    So what types are decidable and what types aren't? How do we tell the difference?
%section
  %h1 Theory of Computation: Hand Wave Edition
  %img{src:'/images/kermit.gif'}
%section
  %h1 Chapter 1: Formal Languages
%section
  %h1 Chomsky Hierarchy
  %img{src: '/images/c_hierarchy.png'}
  %aside.notes
    This is the chomsky hierarchy
    If you've ever taken a compilers course you probably covered it in depth. I'm not doing that. I'm just going to talk about each real quick
%section
  %h1 Regular
  %h2 Boring and Safe
  %h2 No matching parens
  %h2 features: delimiters
%section.fullscreen
  %img{src: '/images/ducks/5126832913_ducklings.jpg'}
%section
  %h1 Context Free
  %h2 less boring, mostly safe
  %h2 features: {(nesting)}
%section.fullscreen
  %img{src: '/images/ducks/4655500165_smily_duck.jpg'}
%section
  %h1 Context Sensitive
  %h2 less boring, mostly safe
  %h2 features: field length prefixes allowed
%section.fullscreen
  %img{src: '/images/ducks/8614455783_scary_duck.jpg'}
%section
  %h1 Recursively Enumerable
  %h2 can describe turing machine
  %h2 most powerful
  %aside.notes
    cool when programming,
    but dont want to expose to someone on the internet
%section.fullscreen
  %img{src: '/images/geese/5547247039_braaak_goose.jpg'}
%section
  %h1 Chomsky Hierarchy
  %img{src: '/images/c_hierarchy.png'}
%section
  %h1 Chapter 1.a: Formal Language Recognition
  %aside.notes
    what do these have to do w/ security?
    what we're really interested in from a sec stand pt is recognition
%section
  %h1 Decidability of formal language recognition
  %img{src: '/images/c_hierarchy_decide_recognition.png'}
  %aside.notes 
    here's what the hierarchy looks like w/ the languages that you can recognize decidably.
    It's most of them.
%section
  %h1 Recursively Enumerable
  %h2 can describe turing machine
  %h2 most powerful
  %aside.notes
    RE is also known as the unrestricted grammar. It has all the things. As it has all the things, parsing it is equivalent to simulating a turing machine.
    eg if you take a programming language as input and then execute it!
%section.fullscreen
  %h1 Goose has root
  %img{src: '/images/geese/5547247039_braaak_goose.jpg'}
%section
  %h1 Context Sensitive 
  %h1 or below
  %h1.fragment Decidable
  %aside.notes
    all the others are decidable, so that's cool.
    decidable languages include most things you would reasonably use like JSON, that said particular instances of JSON / XML are not necessarily decidable
%section.fullscreen
  %img{src: '/images/ducks/4655500165_smily_duck.jpg'}
%section
  %h1 Chapter 1.b: Comparing Formal Language Parsers
%section
  %h1 Context Free has two parts
  %h2.fragment Deterministic
  %h2.fragment Non-Deterministic
%section
  %h2 deterministic context-free
  %h2 comparing parser equivalency:
  %h2.fragment decidable
%section.fullscreen
  %img{src: '/images/ducks/4655500165_smily_duck.jpg'}
%section
  %h1 Woah
  %img.fragment{src: '/images/c_hierarchy_D_ND_CF.png'}
  %aside.notes
    RE is ruby
    yaml also there
    html w/ script RE ish
    D-CF JSON!!
    XML?? context sensitive I think, depending on the schema
%section.fullscreen
  %img{src: '/images/ducks/4655500165_smily_duck.jpg'}
%section
  %h1 recognize inputs completely before processing them
  %aside.notes
    so where were we, oh yeah. lang sec sez qt slide
%section
  %h1 use deterministic context-free languages (or less) as inputs
  %aside.notes
    WIN: use deterministic context-free languages (or less) as inputs
    *least powerful thing you can get away with
    * prefer JSON over XML (because JSON is deterministic context-free)
%section
  %h1 LangSec no noes
  %h2
    %ul
      %li Turing Complete Inputs
      %li ad hoc input validation
      %li weak parsers checking strong languages
%section
  %h1 Turing Complete Inputs
%section.biggest
  %blockquote
    "This system is very extendable/updatable
    because it embeds macros/scripting/programming language in data" --run like hell
  %p -- Science of Insecurity
  %aside.notes
    to quote Meredith's Science of Insecurity
    maybe that'll give you a clue
    eg XML(YAML)
%section
  %h1 ad hoc input validation
  %aside.notes
    when validation & parsing scattered, the machine that does parsing has many more states and potential undefined behaviors
%section
  %h1 AKA Shotgun parsing
  %img{src: '/images/shot_pattern.jpg'}
  %aside.notes
    because parsing's all over the code
%section
  %h1 weak parsers 
  %h1 checking
  %h1 strong languages
%section
  :rubycode
    if in_xml =~ /valid-codes/
      fire_z_missiles(in_xml)
    end
%section
  %h1 TL;DR Use JSON
%section
  %h1 WRT Rails
  %aside.notes
    Okay. Cool. I use Rails. Am I safe? How do I even???
    Rails already deals with this in a lot of different ways. (list a couple quickly)
    eg HTML sanitization
    the reason the xml yaml thing happened is that rails has this big parsing infratracture that sits way in front of your application. it's a big black box.
%section
  %h1 parsing too early, too generally
%section
  %pre.asciiart
    :plain
              |  IN      |
      Rails |[parse   ]|
            |          |
      ------+----------+
      App   |[validate]|
            |[ use    ]|

  %aside.notes
    it parses waaaay before your validation code runs.
    it also parses even if you're not using the thing it's parsing.

    If there's a bug/exploit in the parser,
    it'll happen before your application code even sees the input.

%section
  %pre.asciiart
    :plain
              |  IN      |
      Rails |          |
      ------+----------+
      App   |[parse   ]|
            |[validate]|
            |[ use    ]|

%section
  %h1 Goal:
  %h2.fragment rm -rf undefined_behavior
%section
  %h1 don't allow undefined inputs!
%section
  %h1 ↶
%section
  %h1 Only allow defined inputs!
%section
  %h1 Patched Postel Principle
  - code "diff" do
    :plain
      The Postel Principle Patch:

      --- ietf/postels-principle
      +++ ietf/postels-principle
        
      - Be liberal about what you accept.

      + Be definite about what you accept.(*) 
      +
      + Treat inputs as a language, accept it with a matching computational
      + power, generate its recognizer from its grammar.
      +
      + Treat input-handling computational power as privilege, and reduce it
      + whenever possible.
      +
      +
      + (*) For the sake of your users, be definite about what you accept.
      + Being liberal worked best for simpler protocols and languages,
      + and is in fact limited to such languages; be sure to keep your
      + language regular or at most context free (no length fields).    
      + Being more liberal did not work so well for early IPv4 stacks: 
      + they were initially vulnerable to weak packet parser attacks, and 
      + ended up eliminating many options and features from normal use. 
      + Furthermore, presence of these options in traffic came to be regarded 
      + as a sign of suspicious or malicious activities, to be mitigated by 
      + traffic normalization or outright rejection. At current protocol 
      + complexities, being liberal actually means exposing the users of your 
      + software to intractable or malicious computations. 
  :markdown
    [cite](http://langsec.org/postel-principle-patch.txt)
%section
  %h2
    %blockquote Be definite about what you accept.(*)
%section
  %h2
    %blockquote
      Treat inputs as a language, accept it with a matching computational power, generate its recognizer from its grammar.
%section
  %h2
    %blockquote
      Treat input-handling computational power as privilege, and reduce it whenever possible.
%section
  %h1 Defining inputs...
  %h2.fragment Isn't that a pain?
%section
  %h1 
    %span Yes!
    %span.fragment yes it is!
%section
  %h1 But, we already do!
%section
  %h1 Rails input validation
  %h2.fragment Rails 3 attr_accessible
%%section
  %h1  Rails 3 attr_accessible
  :rubycode
    attr_accessible :name
    attr_accessible :name, :credit_rating,
                    :as => :admin
  :markdown
    [api docs](http://apidock.com/rails/ActiveModel/MassAssignmentSecurity/ClassMethods/attr_accessible)
%section
  :graphviz
    digraph {
      node [style=filled];
      rankdir="LR";
      bytes -> "hashes n arrays";
      "hashes n arrays" -> controller;
      controller -> model [label="Input Checked Here", labelloc=b];
    }
%section
  %h1 pluses
  %h2.fragment all access controlled
  %h2.fragment blows up on bad keys
%section
  %h1 minuses
  %h2.fragment definition / usage in different locations
  %h2.fragment different use case handling

%section
  %h1 Rails input validation
  %h2 Rails 3 attr_accessible
  %h2.fragment Rails 4 Strong Parameters
%%section
  %h1 Rails 4 Strong Parameters
  :rubycode
    params.require(:person).
        permit(:name, :age,
               pets_attributes: 
                 [ :name, :category ])
  :markdown
    [api docs](http://edgeapi.rubyonrails.org/classes/ActionController/StrongParameters.html)
%section
  :graphviz
    digraph {
      node [style=filled];
      rankdir="LR";
      bytes -> "hashes n arrays";
      "hashes n arrays" -> controller  [label="Input Checked Here", labelloc=b];
      controller -> model;
    }
%section
  %h1 Pluses
  %h2.fragment definition / usage in same location
  %h2.fragment schema allows for nesting
%section
  %h1 minuses
  %h2.fragment silently strips unpermitted keys
  %h2.fragment Schema is ambiguous

%section
  %h1 Why not earlier?
%section
  :graphviz
    digraph {
      node [style=filled];
      rankdir="LR";
      bytes -> "hashes n arrays" [label="Input Checked Here", labelloc=b];
      "hashes n arrays" -> controller ;
      controller -> model;
    }
%section.fullscreen
  :markdown
    ![muskox](/images/muskox_logo.png)
%section
  %h2 Muskox is a schema based Parser Generator
%section
  %h2 Give it a JSON Schema definition
  :rubycode
      extend Muskox::Extensions
          add_parser    :user,
            type:       :object,
            properties: {
              name:  { type: :string },
              email: { type: :string }
            }
%section
  %h1 And it will only allow valid strings to be parsed
%section
  :rubycode
    MyParsers.parsers[:user].
      parse(
      %!{"name":"me", "email":"x@y.com"}!)
    # => {"name"=>"me", "email"=>"x@y.com"} 
%section
  :rubycode
    MyParsers.parsers[:user].parse(
      %!{"hash_dos1":1, "hash_dos2":1, "hash_dos3":1}!)
    # Muskox::ParserError: 
    #   Unexpected property: [hash_dos1] at root.
    #   Allowed properties: [name, email]
%section
  %h1 Structure
%section
  %h1 Break Parser in Two
  .graph.fragment
    :graphviz
      digraph {
        node [style=filled];
        rankdir="LR";
        tokenizer -> validator;
      }
%section
  %h1 tokenizer
  %h2.fragment recognizes language (JSON)
  %h2.fragment passes tokens to validator
%section
  %h1 validator
  %h2.fragment validates against provided schema
  %h2.fragment uses tokens to create Ruby objects
%section
  %h1 MuskOx w/ Rails
%section
  %h2 Replace strong params
  :rubycode
    def login_params
      params.require(:user).
        permit(:login, :password)
    end
%section
  %h2 Replace Strong Params
  :rubycode
    muskox_params :user_params do |m|
      m.require(:user).
        permit(:login, :password)
    end
%section
  %h1 Muskox Future
  %h2 new tokenizer formats: XML, Form encoded data, ...
%section
  %h1 References
  %h2 langsec.org
  %h2 github.com/baroquebobcat/muskox
  %aside.notes
    langsec.org has a lot of links to presentations that go through the langsec stuff with more rigor than I did, so if you want to learn more about that, it's a great place to get started.
    Meredith L. Patterson
%section
  %h1  Nick Howard
  %h2  @baroquebobcat
  %img{src:'/images/GnipLogo.png'}