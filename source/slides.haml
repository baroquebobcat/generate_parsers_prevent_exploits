---
title: Slides
layout: presentation
---
%section
  %h1 Generate Parsers! Prevent Exploits!
%section
  %h1 
%section
  %h1 What?
  %h2.fragment exploits!
  %h2.fragment formal languages!
  %h2.fragment generating parsers!
  %h2.fragment ducks!
  %h2.fragment geese!
  %aside.notes
    Today I'm going to talk about exploits. How they relate to formal languages. How generating parsers for said formal languages can help to reduce your apps vulnerability to exploits.
    Also ducks and geese.
%section
  %h1 Exploits! They Suck!
%section
  %h2 Having an app exploited sucks
%section
  %h2 Attackers find
  %p.fragment Chink in armor
  %p.fragment hole in the wall
  %p.fragment crack in the dam
  %p.fragment analogy in analogy
  %p.fragment Achilles Heel
%section
  %h1 Attackers get
  %p.fragment crown jewels
  %p.fragment DB, eval
  %p.fragment shell
  %p.fragment ROOT!!
  %p.fragment the whole kit n' caboodle
%section
  %h1 PSA:
  %h1.fragment Your passwords are hashed and salted, Right?
%section
  %h1 Exploits ~~ Tricks
  %aside.notes
    Exploits feel like tricks.
%section
  %h1 Hard to predict
  %aside.notes
    They're hard to anticipate, and when you look at the different kinds of them, they feel
%section
  %h1 Unrelated
  %p.fragment Buffer Overflow
  %p.fragment SQL Injection
  %p.fragment XSS
  %p.fragment …
  %p.fragment ∞
  %aside.notes
    unrelated to each other.
    What do buffer overlows, SQL injections XSS have in common?
    Feels overwhelming
%section
  %h1 all different?
  %aside.notes
    They seem so different
%section
  %h1
    No
    %span.fragment !
    %span.fragment !
    %span.fragment !
  %aside.notes
    But they're not! not !
%section
  %h1 Exploits are all the same!
  %aside.notes
    Exploits are all the same kind of thing!
%section
  %h1 Unexpected Computation!
  %aside.notes
    Exploits are just unexpected computation that exist within your application.
%section
  %h1 Computation!
  %aside.notes
    And if they're computation, we can use tools for analyzing computation to better understand them and prevent them from showing up in our applications.
%section
  %h1 Theory of Computation: cliff notes
  %aside.notes
    :plain
      Yes, I'm talking about theory of computation.
      See! Relevant!
      Break out your text books and think back to those senior / grad level classes.
%section
  %h1 *NOT YET*
  %aside.notes
    :plain
      ha ha, not yet. we'll get to that I promise, in a bit.
%section
  %h1 Exploit != Trick
  %aside.notes
    Exploits aren't tricks. They're just means of computing things.
%section
  %h1 Exploit == Machine
  %aside.notes
    they're computing machines. And we can think about them as computing machines
    Since they're machines, let's talk about how they work.
%section
  %h1 
    Exploit === Weird Machine
    *
  %h2.fragment * technical term
  %aside.notes
    But they're weird machines.
%section
  %h1 How does an exploit work?
  %aside.notes
    So, what do exploits do?
%section
  %h2
    %ol
      %li.fragment Takes Input
      %li.fragment ??? (Does Stuff)
      %li.fragment
        %span Output
        %span.fragment /
        %span.fragment profit
    %h2.fragment (profit is important w/ exploits)
  %aside.notes
    slide contents
    so basically that's the same as any kind of computing machine really.
    program
%section
  %h1 Same as regular program
%section
  %h1 What's different?
  %aside.notes
    But there's a couple things that are different. Let's talk about exploit anatomy
%section
  %h1 Exploit anatomy
  %h2.fragment undefined behavior in your app
  %h2.fragment communication channels
  %aside.notes
    exploits are made up of two things.
    1. areas of undefined behavior in your applications
    2. communication channels to those areas of undefined behavior
    ideally you don't have 1., but as we usually write programs in Turing complete environments, that's hard to prove
    Easier is to attack number 2.
%section
  %h1 Exploits live
  %h1 inside
  %h1 your app / framework
  %aside.notes
    Where they live is inside your application. And because they live there, the way they get input is through your applications inputs.
%section
  %h1
    Input Via 
    Host Application's
    Inputs
  %aside.notes
    They have to get their input indirectly. Through your applications inputs.
    And that's because the inputs they receive come through the inputs to the host application
%section
  :graphviz
    digraph G {
      size = "7.5,10";

      compound=true;
      rankdir="LR";
      node [shape=box fontsize=10 fontname="Verdana" style="filled"];

      subgraph cluster0 {
       // height = 100;
        //scale = 2;
        label = "Your App";
        style="filled";
        //padding [style="invis"];
        "Exploit";
      }
      { node [shape=circle]; IN OUT  };
      "Exploit" -> IN [dir=back];
      "Exploit" -> OUT;
    }
  %aside.notes
    When an attacker wants to talk to an exploit, or see if one's there, they need to route input to that exploit through your application. So how does that work? Well,
%section
  %pre{style: "font-size:200%; width: 50%"}
    :plain
      App |
        | <- IN
        |

  %aside.notes
    (zoomin'in)
    When input for an exploit comes to your application
    Your application is sent some bad input
%section
  %h2 (past app code)
  %pre{style: "font-size:200%; width: 50%"}
    :plain
      App Code |
         /---| <- IN
         |   |
         v   |
  %aside.notes
    As it's processed, it somehow skips past your applications code. past the path you intended it to take, and instead goes somewhere else.

%section
  %h2 (to exploit)
  %pre{style: "font-size:200%; width: 50%"}
    :plain
           |     |
         v     |
      Exploit  |
  %aside.notes
    And ends up providing input to the exploit instead.
    You can see this in any exploit. SQL injection etc.
    And the exploit will send output back to the attacker, and they'll be able to play with the input to see what kind of response they get and what kinds of operations the exploit supports.
%section
  :graphviz
    digraph G {
      size = "7.5,10";

      compound=true;
      rankdir="LR";
      node [shape=box fontsize=10 fontname="Verdana" style="filled"];

      subgraph cluster0 {
       // height = 100;
        //scale = 2;
        label = "Your App";
        style="filled";
        //padding [style="invis"];
        "Exploit";
      }
      { node [shape=circle]; IN OUT  };
      "Exploit" -> IN [dir=back];
      "Exploit" -> OUT;
    }
%section
  %h1 stopping exploits
  %aside.notes
    So how do you stop exploits? Easiest way is to control their inputs
%section
  %h1 IN - what is it?
  %aside.notes
    but what are their inputs?
%section
  %h1 IN:
  %h2 instructions to the exploit
  %aside.notes
    Weird language
    crafted input
%section
  %h1 Exploit == Weird Machine
  %aside.notes
    Remember exploits are a weird machine, so these crafted inputs are the weird instructions for that weird machine
%section
  %h1 IN == program in exploit-ese
  %aside.notes
    ie a program for that weird machine
%section
  %h1 asm_sql_injection anyone?
  %aside.notes
    The input is like an assembly language, but for the specific weird machine.
%section
  %h1 
    Example:
    %br
    Rails XML(type=yaml)
  %aside.notes
    Let's look at an example, the remote code exe bug from last year in rail's XML parser
%section
  :graphviz
    digraph G {
      size = "7.5,10";

      compound=true;
      rankdir="LR";
      node [shape=box fontsize=10 fontname="Verdana" style="filled"];

      subgraph cluster0 {
       // height = 100;
        //scale = 2;
        label = "Rails";
        style="filled";
        //padding [style="invis"];

        subgraph cluster1 {
         // height = 100;
          //scale = 2;
          label = "XML Parser";
          style="filled";
          //padding [style="invis"];
          "Exploit via YAML";
        }
      }
      { node [shape=circle]; IN OUT  };
      "Exploit via YAML" -> IN [dir=back];
      "Exploit via YAML" -> OUT;
    }
  %aside.notes
    Within the XML parser was some ill defined behavior that allowed yaml as an XML content type.
    yaml isn't safe--you can create Ruby objects of arbitrary classes--which allowed access to eval
%section
  %h2 (not actual program)
  - code "xml" do
    :plain
      <yaml type="yaml">
      ---- !ruby/object:Evil
        hi: eval_me
      </yaml>
%section
  %h1 ...
%section
  %h1 Running Ruby!
%section
  %h1 :-(
%section
  %h1 PSA:
  %h1.fragment Everybody's patched, right?
%section
  %h1 What's the real problem here?
%section
  %h1 Bad Input validation!
  %aside.notes
    these problems are caused by accepting inputs that your application handles incorrectly.
%section
  %h1 What's the fix
  %h2.fragment Good Input Validation!
%section
  %h1 No Bad input allowed!
%section
  %h1 But How?
  %h2.fragment treat input as formal language
%section
  %h1
    :markdown
      _decide_ whether input is good/bad.
%section
  %h1 Decide!
%section
  %h1 Theory of Computation: cliff notes
%section
  %h1 *Not Yet*
%section
  %h1
    :markdown
      _recognize_ good input before processing
%section
  %h1 Recognize!
%section
  %h1 Theory of Computation: cliff notes
%section
  %h1 Almost...
%section
  %h1 LangSec
  %aside.notes
    Taking a step back & going to talk about langsec
    I got interested in lang sec in 2012 when I saw a talk at an infosec conference called Shmoocon by Meredith L Patterson. It was awesome.
%section
  %h1 Language Theoretic Security
  %aside.notes

    What is langsec?
    langsec is using Theory of Computation and an understanding of formal language to reason about the security of applications and protocols
    part of infosec

    things that are bad according to lang sec
    1. using parsers with the wrong amount of computational power for the language
    2. parsing & validating input in an ad hoc way
    3. using languages that are turing complete as inputs
    4. using languages whose parsers cannot be compared (context sensitive)
    
    1. what does that even mean?
    here there be dragons
    well remember how you're not supposed to use Regex to parse XML, (unless you're using perl in which case, go ahead, but here there be dragons)
    there's a ToC reason for that.

    * treat computational power as a priviledged resource and that includes parsing
    * %section
    (screenshot)
    http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
%section
  %h1 Theory of Computation: cliff notes
%section
  %h1 Theory of Computation: hand wave section
%section
  %h1 decidability
%section
  %h1 can we answer a yes / no question and not run to infinity
%section
  %h1 turns out sometimes it's impossible
%section
  %h1 For real!
%section
  %h1 Theory of Computation: /hand wave section
%section
  %h1 But, input validation
%section
  %h1 your app's input ~= formal language
%section
  %h1 merely recognizing formal languages can sometimes be undecidable
%section
  %h1 ???
%section
  %h1 decidability chat
  %h2.fragment App: Can I parse this?
  %h2.fragment Parser: *Runs forever*
  %aside.notes
    actually, a lot of exploits work this way. the goal is to ddos
%section
  %h1 What's an undecidable language?
  %aside.notes
    this begs the question, how do I decide (*snork) if my input is decidable?
%section
  :markdown
    Chomsky Hierarchy
    ========================
    * Recursively Enumerable
    * Context Sensitive
    * Context Free
    * Regular
  %aside.notes
    turns out some guy in the '50s came up with a chart for that. noam chomsky... never heard of him...
    There are four lights^H classes. They contain each other so that less complex grammars can be represented within more complex.
%section
  %h1 Decidable grammars highlighted
  :markdown
    * Recursively Enumerable
    * *Context Sensitive*
    * *Context Free*
    * *Regular*
  %aside.notes
%section
  %h1 Regular
  %h2 Boring and Safe
  %h2 No matching parens
  %h2 common features: delimiters
  %h2 recognizing is decidable
%section
  %h1 Context Free
  %h2 less boring, mostly safe
  %h2 (matching parens)
  %h2 recognizing is decidable
%section
  %h1 Context Sensitive
  %h2 less boring, mostly safe
  %h2 features: field length prefixes allowed
  %h2 recognizing is decidable
%section
  %h1 Recursively Enumerable
  %h2 can describe turing machine
  %h2 most powerful
  %h2 recognizing is not decidable!
%section
  %h1 Fail!
%section
  %h1 look back at XML(type=yaml)
%section
  %h1 YAML mixes parsing / processing
%section
  %h1 mixes parsing / processing -> undefined behavior
%section
  %h1 bad!
%section
  %h1 Goal:
  %h2.fragment rm -rf undefined_behavior
%section
  %h1 don't allow undefined inputs!
%section
  %h1 ↶
%section
  %h1 Only allow defined inputs!
%section
  %h1 Patched Postel Principle
  - code "diff" do
    :plain
      The Postel Principle Patch:

      --- ietf/postels-principle
      +++ ietf/postels-principle
        
      - Be liberal about what you accept.

      + Be definite about what you accept.(*) 
      +
      + Treat inputs as a language, accept it with a matching computational
      + power, generate its recognizer from its grammar.
      +
      + Treat input-handling computational power as privilege, and reduce it
      + whenever possible.
      +
      +
      + (*) For the sake of your users, be definite about what you accept.
      + Being liberal worked best for simpler protocols and languages,
      + and is in fact limited to such languages; be sure to keep your
      + language regular or at most context free (no length fields).    
      + Being more liberal did not work so well for early IPv4 stacks: 
      + they were initially vulnerable to weak packet parser attacks, and 
      + ended up eliminating many options and features from normal use. 
      + Furthermore, presence of these options in traffic came to be regarded 
      + as a sign of suspicious or malicious activities, to be mitigated by 
      + traffic normalization or outright rejection. At current protocol 
      + complexities, being liberal actually means exposing the users of your 
      + software to intractable or malicious computations. 
  :markdown
    [cite](http://langsec.org/postel-principle-patch.txt)
%section
  %blockquote.bigger Be definite about what you accept.(*)
%section
  %blockquote.bigger 
    Treat inputs as a language, accept it with a matching computational power, generate its recognizer from its grammar.
%section
  %blockquote.bigger
    Treat input-handling computational power as privilege, and reduce it whenever possible.
%section
  %h1 Defining inputs...
  %h2.fragment Isn't that a pain?
%section
  %h1 
    %span Yes!
    %span.fragment yes it is!
%section
  %h1 But, we already do!
%section
  %h1 Rails input validation
  %h2.fragment Rails 3 attr_accessible
%%section
  %h1  Rails 3 attr_accessible
  - code "ruby" do
    :plain
      attr_accessible :name
      attr_accessible :name, :credit_rating, :as => :admin
  :markdown
    [api docs](http://apidock.com/rails/ActiveModel/MassAssignmentSecurity/ClassMethods/attr_accessible)
%section
  :graphviz
    digraph {
      rankdir="LR";
      bytes -> "hashes n arrays";
      "hashes n arrays" -> controller;
      controller -> model [label="Input Checked Here", labelloc=b];
    }
%section
  %h1 pluses
  %h2.fragment all access controlled
  %h2.fragment blows up on bad keys
%section
  %h1 minuses
  %h2.fragment definition / usage in different locations
  %h2.fragment different use case handling

%section
  %h1 Rails input validation
  %h2 Rails 3 attr_accessible
  %h2.fragment Rails 4 Strong Parameters
%%section
  %h1 Rails 4 Strong Parameters
  - code "ruby" do
    :plain
      params.require(:person).
          permit(:name, :age, pets_attributes: [ :name, :category ])
  :markdown
    [api docs](http://edgeapi.rubyonrails.org/classes/ActionController/StrongParameters.html)

%section
  %h1 Pluses
  %h2.fragment access / usage in same location
  %h2.fragment schema allows for nesting
%section
  %h1 minuses
  %h2.fragment silently strips unpermitted keys
  %h2.fragment Schema is ambiguous
%section
  %h1 Why not earlier?
%section
  :graphviz
    digraph {
      rankdir="LR";
      bytes -> "hashes n arrays" [label="Input Checked Here", labelloc=b];
      "hashes n arrays" -> controller ;
      controller -> model;
    }
%section
  :markdown
    ![muskox](/images/muskox_logo.png)
%section
  %h2 Muskox is a schema based Parser Generator
%section
  %h2 Give it a JSON Schema definition
  - code "ruby" do
    :plain
      extend Muskox::Extensions
          add_parser    :user,
            type:       :object,
            properties: {
              name:  { type: :string },
              email: { type: :string }
            }
%section
  %h1 And it will only allow valid strings to be parsed
%section
  .bigger
    - code "ruby" do
      :plain
        MyParsers.parsers[:user].parse(
          %!{"name":"me", "email":"x@y.com"}!)
        # => {"name"=>"me", "email"=>"x@y.com"} 
%section
  .bigger
    - code "ruby" do
      :plain
        MyParsers.parsers[:user].parse(
          %!{"hash_dos1":1, "hash_dos2":1, "hash_dos3":1}!)
        # Muskox::ParserError: 
        #   Unexpected property: [hash_dos1] at root.
        #   Allowed properties: [name, email]
%section
  %h1 Structure
%section
  %h1 Break Parser in Two
  .graph.fragment
    :graphviz
      digraph {
        rankdir="LR";
        tokenizer -> validator;
      }
%section
  %h1 tokenizer
  %h2.fragment recognizes language (JSON)
  %h2.fragment passes tokens to validator
%section
  %h1 validator
  %h2.fragment validates against provided schema
  %h2.fragment uses tokens to create Ruby objects
%section
  %h1 MuskOx w/ Rails
%section
  %h1 Replace Strong Params
  - code "ruby" do
    :plain
      def login_params
        params.require(:user).permit(:login, :password)
      end
%section
  %h1 Replace Strong Params
  - code "ruby" do
    :plain
      muskox_params :user_params do |m|
        m.require(:user).permit(:login, :password)
      end
%section
  %h1 Muskox Future
  %h2 new tokenizer formats: XML, Form encoded data, ...
%section
  %h1 References
  %h2 langsec.org
  %h2 github.com/baroquebobcat/muskox
  %aside.notes
    langsec.org has a lot of links to presentations that go through the langsec stuff with more rigor than I did, so if you want to learn more about that, it's a great place to get started.
    Meredith L. Patterson
%section
  %h1 Qs / Interesting Automata?
%section
  :markdown
    ![gnip](/images/GnipLogo.png)